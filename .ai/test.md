Czy widok tworzenia fiszek i widok przeglądania powinny być osobnymi widokami, czy jednym widokiem z przełączaniem trybów?
zgodnie z rekomedacja
Rekomendacja: Utworzyć osobne widoki (routes) dla tworzenia i przeglądania fiszek, z możliwością łatwego przełączania przez nawigację. Widok tworzenia (/create) powinien zawierać: Shadcn/ui Textarea dla pola tekstowego z klasami Tailwind (max-w-2xl, mx-auto, p-4), interaktywny obszar wyboru słów z Tailwind (flex flex-wrap gap-2, p-4, rounded-lg border), Shadcn/ui Button dla "Accept" z wariantem "default". Widok przeglądania (/study lub /flashcards) powinien używać Shadcn/ui Card dla wyświetlania kart, Shadcn/ui Tabs lub ToggleGroup dla przełączania między trybem przeglądania (order=id) a trybem powtórek (order=random). Osobne widoki ułatwiają zarządzanie stanem i optymalizację wydajności.
Jak obsługiwać wybór języka źródłowego i docelowego, skoro API nie zawiera pól dla języków w schemacie fiszki?
nie zwracamy uwagi na jezyki
Rekomendacja: W MVP języki mogą być przechowywane lokalnie w stanie aplikacji lub w localStorage jako preferencje użytkownika, bez zapisywania w bazie. Alternatywnie, jeśli języki są wymagane dla każdej fiszki (US-019), należy rozszerzyć schemat API o pola source_language i target_language w tabeli flashcards. Dla MVP zaleca się przechowywanie języków jako metadanych w UI bez integracji z API, jeśli nie są krytyczne dla funkcjonalności.
Czy sesja powtórek powinna być osobnym widokiem czy trybem w widoku przeglądania?
tak jak rekomenacja 
Rekomendacja: Sesja powtórek powinna być trybem w widoku przeglądania, aktywowanym Shadcn/ui Button z wariantem "default" i klasami Tailwind (w-full sm:w-auto). Po aktywacji widok przełącza się na tryb powtórek, pobiera fiszki z order=random i wyświetla je w losowej kolejności. Stan sesji (aktualna fiszka, pozostałe) powinien być zarządzany lokalnie w komponencie React. Po zakończeniu cyklu wyświetlić Shadcn/ui Alert z komunikatem i Shadcn/ui Button do rozpoczęcia nowego cyklu. Użyć Tailwind do stylowania licznika postępu (flex items-center gap-2, text-sm text-muted-foreground).
Jak zarządzać tokenem JWT Supabase w Astro — przez middleware, w komponentach React, czy przez Astro API routes?
bdz uzywac jwt które wdrozymy pozniejszym etapie 
Rekomendacja: Użyć Supabase Auth SDK bezpośrednio w komponentach React do uwierzytelniania i zarządzania sesją. Token JWT powinien być przechowywany w bezpiecznym storage (httpOnly cookies przez Supabase) i automatycznie dołączany do żądań przez Supabase client. Astro middleware powinno weryfikować autoryzację dla chronionych routes i przekierowywać niezalogowanych użytkowników. API routes w Astro powinny odbierać token z nagłówka Authorization i weryfikować go przed wykonaniem operacji.
Jak obsługiwać tworzenie wielu fiszek z tego samego tekstu — czy każda fiszka jest zapisywana natychmiast po kliknięciu "Accept", czy użytkownik może przygotować wiele fiszek i zapisać je razem?
zgodnie z rekomendacja
Rekomendacja: Każda fiszka powinna być zapisywana natychmiast po kliknięciu "Accept" (POST /api/flashcards), zgodnie z US-004–US-007. Tekst źródłowy pozostaje w polu, umożliwiając tworzenie kolejnych fiszek. Shadcn/ui Button z disabled state podczas loading (isLoading prop) i Tailwind classes (w-full sm:w-auto). Podczas zapisu wyświetlić Shadcn/ui Skeleton lub Spinner z Tailwind (animate-spin). Po sukcesie pokazać Shadcn/ui Toast z komunikatem potwierdzenia (variant: "success") lub Shadcn/ui Alert z klasami Tailwind (border-green-500 bg-green-50 text-green-800).
Czy implementować optimistic updates przy edycji i usuwaniu fiszek, czy czekać na odpowiedź API?
zgodnie z rekomenacja
Rekomendacja: Dla MVP zaleca się optimistic updates dla lepszego UX. Przy edycji (PATCH) i usuwaniu (DELETE) natychmiast zaktualizować UI, a w razie błędu API cofnąć zmiany i wyświetlić Shadcn/ui Toast z wariantem "destructive" lub Shadcn/ui Alert z klasami Tailwind (border-red-500 bg-red-50 text-red-800). To poprawia responsywność, szczególnie przy słabym połączeniu. Dla operacji tworzenia (POST) czekać na odpowiedź API, aby uzyskać wygenerowane ID fiszki. Użyć Shadcn/ui Dialog dla formularza edycji z Shadcn/ui Input i Textarea, stylowanych Tailwind (max-w-md mx-auto).
Jak obsługiwać paginację i ładowanie dużej liczby fiszek, skoro API wspiera limit/offset, ale PRD nie wspomina o paginacji w UI?
zgodnie z rekomendacja
Rekomendacja: W MVP pobierać wszystkie fiszki użytkownika na początku (bez limit/offset) i zarządzać nimi lokalnie w stanie React. Dla większych kolekcji (>1000) rozważyć lazy loading lub infinite scroll. Endpoint /api/flashcards/count użyć do wyświetlenia statystyki w Shadcn/ui Card z klasami Tailwind (p-4, rounded-lg, border) lub Shadcn/ui Badge z klasami (text-lg font-semibold). W przyszłości, gdy liczba fiszek wzrośnie, dodać paginację z Shadcn/ui Pagination component i limit/offset.
Czy używać Supabase client bezpośrednio w komponentach React, czy zawsze przez Astro API routes?
zgodnie z rekomenacja 
Rekomendacja: Dla MVP używać Astro API routes jako warstwy abstrakcji między frontendem a Supabase. Komponenty React powinny wywoływać API routes (/api/flashcards), nie bezpośrednio Supabase client. To zapewnia spójny interfejs REST, łatwiejsze testowanie, centralną walidację i możliwość dodania dodatkowej logiki. W przyszłości można rozważyć bezpośrednie wywołania Supabase dla prostych operacji.
Jak obsługiwać stany loading, error i empty state w komponentach UI?
zgodnie z rekomendacja uzywaj tez tailwind i shadcn
Rekomendacja: Zaimplementować dedykowane komponenty/stany używając Shadcn/ui i Tailwind: Loading - Shadcn/ui Skeleton z klasami Tailwind (h-32 w-full rounded-lg animate-pulse) lub Shadcn/ui Spinner z Tailwind (animate-spin h-8 w-8). Error - Shadcn/ui Alert z wariantem "destructive" i Shadcn/ui Button "Spróbuj ponownie" z klasami Tailwind (mt-4), alternatywnie Shadcn/ui Toast. Empty - Shadcn/ui Card z klasami Tailwind (p-8 text-center) zawierający tekst "Nie masz jeszcze fiszek" i Shadcn/ui Button z linkiem do /create. Stany zarządzane przez useState/useEffect. Dla błędów API użyć struktury { error: { code, message, details } } z API planu i mapować kody na komunikaty po polsku w Shadcn/ui Alert.
Jak zaimplementować efekt obrotu karty (flip) i swipe gestures w sposób responsywny i dostępny?
zgodnie z rekomendacja lub jesli się da to uzyj tailwind lub shadcn lub oba 
Rekomendacja: Efekt obrotu zaimplementować używając Tailwind CSS transforms (transform-gpu, perspective-1000, rotate-y-180) z transitions (transition-transform duration-500 ease-in-out) i Shadcn/ui Card jako kontener. Alternatywnie użyć biblioteki react-card-flip z Tailwind classes dla stylowania. Swipe gestures zaimplementować przez react-swipeable z Tailwind classes (touch-pan-x, select-none) lub Hammer.js, z fallbackiem na Shadcn/ui Button z ikonami ChevronLeft/ChevronRight (lucide-react) i klasami Tailwind (absolute top-1/2 -translate-y-1/2 left-4 right-4). Zapewnić dostępność: aria-labels, obsługa klawiatury (strzałki, Enter do obrotu), focus management. Karty powinny być responsywne z Tailwind (max-w-md mx-auto w-full sm:w-96, aspect-[3/4]) i działać zarówno na desktopie (mysz), jak i mobile (dotyk). Użyć Shadcn/ui Card z klasami Tailwind (cursor-pointer hover:shadow-lg transition-shadow) dla interaktywności.
</pytania>